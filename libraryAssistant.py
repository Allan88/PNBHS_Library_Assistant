import csv
import operator
from datetime import date
from tkinter import *
from tkinter import filedialog
from tkinter import messagebox

from classes.offense import Offense
from classes.student import Student


def clean_barcode_file():
    filename = \
        filedialog.askopenfilename(
            initialdir="T:/Library/Data/STOCKTAKE",
            title="Pick a file to clean",
            filetypes=(("txt files", "*.txt"), ("All files", "*.*")))

    if len(filename) > 0:
        with open(filename, "r") as file:
            content = file.readlines()
        content = [x.strip() for x in content]

        for i in range(len(content)):
            # Remove non alphanumeric endings generated by the crappy scanner
            for j in range(len(content[i])):
                if not str.isalnum(content[i][j]):
                    content[i] = content[i][:j]

            # Remove trailing letters from the end if they are not an X
            for k in range(len(content[i]) - 1, 0, -1):
                if not str.isdigit(content[i][k]) and content[i][k] != "X":
                    content[i] = content[i][:k]

            # If it starts with A7, length = 7 characters
            if content[i].startswith("A7"):
                content[i] = content[i][:7]

            # If it starts with A007, length = 9 characters
            if content[i].startswith("A007"):
                content[i] = content[i][:9]

            # If it starts with A0006, length = 10 characters
            if content[i].startswith("A0006"):
                content[i] = content[i][:10]

            # If it starts with A006, length = 9 characters
            if content[i].startswith("A006"):
                content[i] = content[i][:9]

        with open((filename[:-4] + " Clean" + ".txt"), "w") as outfile:
            for line in content:
                outfile.write(line + "\n")

        messagebox.showinfo("Done", "File successfully cleaned!")


def match_criteria(csv_row):
    """
    Remove title rows from the CSV data
    :param csv_row: Data from the overdue and fines CSVs
    :return: True if row is not a title row
    """
    if csv_row[3].startswith('P') \
            or csv_row[0].startswith('Date') \
            or csv_row[1].startswith('Class') \
            or csv_row[1].startswith('Name') \
            or csv_row[1].startswith('Borrower') \
            or csv_row[1].startswith('Vertical'):
        return False
    else:
        return True


def create_offense_from_overdue(author_info, student_info, student):
    """

    :param author_info: Line 1 of the CSV data
    :param student_info: Line 2 of the CSV data
    :param student: A Student object
    :return: None. Appends a new offense to student list of offenses
    """
    offense = Offense()
    offense.dueDate = date(int(author_info[10].split('/')[2]),
                           int(author_info[10].split('/')[1]),
                           int(author_info[10].split('/')[0]))
    offense.classification = author_info[9].strip()
    offense.barcode = student_info[12].strip()
    offense.type = author_info[7].strip()
    offense.title = student_info[6].strip()
    offense.author = author_info[4].strip()
    student.list_of_offenses.append(offense)


def create_offense_from_fine(student_info, fine_info, student):
    offense = Offense()
    offense.title = fine_info[7].strip()
    offense.fine = float(student_info[-1][1:])
    student.list_of_offenses.append(offense)


class App:
    def __init__(self, master):
        master.minsize(width=360, height=240)
        self.master = master
        frame = Frame(master)
        frame.pack()
        self.clean_button = Button(
            frame, text='Clean a barcode file',
            command=clean_barcode_file
        )
        self.clean_button.grid(row=0, column=0)
        self.merge_button = Button(
            frame, text='Merge fines and overdue books',
            command=self.merge_file_select
        )
        self.merge_button.grid(row=1, column=0)
        self.exit_button = Button(
            frame, text='Exit', fg='red', command=frame.quit
        )
        self.exit_button.grid(row=2, column=0)

        self.list_of_offenders = {}
        self.overdue_books_csv = ""
        self.fines_csv = ""

    def merge_file_select(self):
        """
        Create file selector pop up with command to merge files
        :return:
        """
        self.overdue_books_csv = ""
        self.fines_csv = ""

        def select_overdue():
            self.overdue_books_csv = \
                filedialog.askopenfilename(title='Select overdue books CSV',
                                           filetypes=(("CSV files",
                                                       "*.csv"),
                                                      ("All files", "*.*")))
            Label(file_selection, text='...' + self.overdue_books_csv[
                                               -50:]).grid(row=1,
                                                           column=1)

        def select_fines():
            self.fines_csv = \
                filedialog.askopenfilename(title='Select fines CSV',
                                           filetypes=(("CSV files",
                                                       "*.csv"),
                                                      ("All files", "*.*")))
            Label(file_selection,
                  text='...' + self.fines_csv[-50:]).grid(row=2, column=1)

        def merge():
            if len(self.overdue_books_csv) > 3 and len(self.fines_csv) > 3:
                self.merge_csv(self.overdue_books_csv, self.fines_csv)
                self.write_csv()
                messagebox.showinfo('Success!', 'Files merged successfully.')
                self.overdue_books_csv = ""
                self.fines_csv = ""
            else:
                messagebox.showerror('Code red! Code red!',
                                     'Please select the 2 CSVs to merge first!')

        file_selection = Toplevel(self.master)
        file_selection.wm_title('Merge file selector')
        file_selection.minsize(width=240, height=240)
        file_selection.geometry(
            "550x250+%d+%d" % (screen_width / 2 - 275, screen_height / 2 - 125))

        # User interface grid
        Label(file_selection, text="Select two files:").grid(row=0, column=0)
        Label(file_selection, text=self.overdue_books_csv).grid(row=1, column=1)
        Label(file_selection, text=self.fines_csv).grid(row=2, column=1)
        Button(file_selection, text="Select overdue books CSV",
               command=select_overdue).grid(row=1,
                                            column=0)
        Button(file_selection, text="Select fines list CSV",
               command=select_fines).grid(row=2,
                                          column=0)
        Button(file_selection, text="Merge like a zip",
               command=merge).grid(row=3,
                                   column=1)
        Button(
            file_selection, text='Done', fg='red',
            command=file_selection.destroy
        ).grid(row=3, column=0)

    def merge_csv(self, overdue_books_csv, fines_csv):
        """

        :param overdue_books_csv: Overdue books CSV generated by AccessIt
        :param fines_csv: Fines CSV generated by AccessIt
        :return:
        """

        with open(overdue_books_csv) as csv_file:
            read_csv = list(csv.reader(csv_file, delimiter=','))

            # Get each pair of lines and shape their info into Student and
            # Offense classes
            for author_info, student_info in zip(
                    list(filter(match_criteria, read_csv[::2])),
                    list(filter(match_criteria, read_csv[1::2]))):

                # Extract student information
                form_class = student_info[1].strip()
                student_id = int(author_info[2].strip())
                name = student_info[2].strip()

                # Create new Student if not already in dictionary
                if student_id not in self.list_of_offenders.keys():
                    self.list_of_offenders[student_id] = Student(
                        form_class,
                        student_id,
                        name)
                    student = self.list_of_offenders[student_id]
                else:
                    student = self.list_of_offenders[student_id]

                # Add the corresponding overdue book to the student's record
                create_offense_from_overdue(author_info, student_info, student)

        with open(fines_csv) as csv_file:
            read_csv = list(csv.reader(csv_file, delimiter=','))

            # Get each pair of lines and shape their info into Student and
            # Offense classes
            for student_info, fine_info in zip(
                    list(filter(match_criteria, read_csv[::2])),
                    list(filter(match_criteria, read_csv[1::2]))):

                # Extract student information
                form_class = student_info[2].strip()
                student_id = int(student_info[1].strip())
                name = fine_info[1]

                # Create new Student if not already in dictionary
                if student_id not in self.list_of_offenders.keys():
                    self.list_of_offenders[student_id] = Student(
                        form_class,
                        student_id,
                        name)
                    student = self.list_of_offenders[student_id]
                else:
                    student = self.list_of_offenders[student_id]

                # Add the corresponding fine to the student's record
                create_offense_from_fine(student_info, fine_info, student)

    def write_csv(self):
        output_file_name = filedialog.asksaveasfilename(
            filetypes=(("CSV file", "*.csv"), ("All files", "*.*")))
        with open(output_file_name + '.csv', 'w') as output_csv:
            output_writer = csv.writer(output_csv, delimiter=',')
            output_writer.writerow(
                ['Number', 'Name', 'Class', 'Title of very late book',
                 'Barcode', 'Type', 'Classification', 'Author', 'Date Due',
                 'Charge']
            )
            for student in sorted(self.list_of_offenders.values(),
                                  key=operator.attrgetter('name')):
                row = [student.student_id, student.name, student.form_class]
                for offense in student.list_of_offenses:
                    row.append(offense.title)
                    row.append(offense.barcode)
                    row.append(offense.type)
                    row.append(offense.classification)
                    row.append(offense.author)
                    row.append(offense.dueDate)
                    row.append('${:,.2f}'.format(offense.fine))

                    output_writer.writerow(row)
                    row = row[:3]


if __name__ == '__main__':
    root = Tk()
    root.title('Library Assistant')
    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()
    root.geometry(
        "550x250+%d+%d" % (screen_width / 2 - 275, screen_height / 2 - 125))

    # Bring window to front
    root.lift()
    root.attributes('-topmost', True)
    root.after_idle(root.attributes, '-topmost', False)

    app = App(root)
    root.mainloop()
    root.destroy()
